{"pages":[{"title":"关于","text":"关于本站使用基于node.js的轻量级博客框架hexo搭建，themes采用Icarus 关于个人现大三软件工程，方向前端，喜欢混科技圈，热爱计算机各种技术深爱搞机，拿到第一步手机就开始捣鼓，上初一搞过 MTK 思凯 mrp 格式的 app，还记得*#*#220807#这些神奇的代码，初二用过 s60v5 平台的手机,搞过 sis，sisx 格式的签名破解，上初三拿到第一步安卓手机开始捣鼓反编译修改系统，同时开始自学了一点 C 语言跟 java，高二开始自学安卓原生开发，全程都是使用 Aide，中途玩过逆向，tiny等免流，对物联网单片机等都有一些了解，使用过 树莓派、Arduino、Esp8266、ch-08 等单片机开发板，独立开发了一个简单的遥控车，对 ch340x，cp210x 等驱动有一定的了解，现致力于Vue，React，Echarts等前端框架的学习，以及个人的开源与上线个人站点。 总结:前端，后端，移动客户端，产品，UI，都在学，除前端外其他基本全是野路子。 我的照片高中 大学 爱好逃离塔科夫忠实玩家 足球 代码 剧本杀 工作经历截止 2022年4月20日，一共有过三次工作经历，即使目前我参加的所有工作中没有和代码相关的，但也挺有趣于是愿意分享一下。 书法兴趣班那是在大二的暑假，在成都中坝，我和高中的三个兄弟一起策划就地找个工作，想着这样又有工资拿又能一起玩耍，挺好。我们在中坝转了一圈，有游泳班，有补课机构，有健身房，甚至还有在boss上都还在发布招聘公告但我们一去实地需要坐一部藏在深巷里的电梯，电梯门一打开迎面的是一堵水泥墙（墙上写着铺面已转让的告示）这样的阴森饭店。我们因为种种原因都没有被录用，但是在最后一家看起来还不错的少儿书法培训机构愿意去接待我们。接待我们的是一名可能只比我们大几岁的大学学姐。我们是临时录用的，她给我们说只能分配给我们发传单，拉客户的工作。说起发传单，反正我是挺不愿意的，可能是恐惧，害羞，换位思考后我也挺不待见给我发传单的人。但望向丁逼，赵杨朋，刘川。他们三看上去挺有自信，我们最后签了兼职工作的合同，薪酬是15元一小时，她通知我们下周一来上班。到了上班的时间，我早早的赶到了店里，赵杨朋依旧迟到。但还好，学姐并没有责备。她给了我们一张客户登记表，一支笔，一把店里的传单。领我们分别去了商城门口，地铁口，小区大门口。我们的任务就是拉客户！我被分配在了中坝鹏瑞利商场的门口，此刻我充满了自信，但谁呈想到一段艰难的时期来了。面对商城门口的车水马龙，我尽力的往人们的手中递着传单，向带着小朋友的家长介绍着我的业务。但在这充满竞争的社会，没有想象中的敬贤礼士，好言好语，换来的更多是一个白眼，一张冷漠的表情。此刻我的心情来到了冰点。当然也有令人安慰的事情，我遇到了一位阿姨，他知道我是附近书法培训班的。她真的很愿意去帮助我，即使她并没有让自己小孩报名书法培训班的需求，她把她的信息填在了客户登记表上。最后经历了难熬的4小时，我们下班了。他们哥三一个客户也没有拉到，最终我们的战果是4人·一个下午·一名客户。回到店里，我看到学姐的表情已经不对了，她让我们先回去。第二天学姐给我们发了微信，通知说我们不用再来了，第一天的工资月底会发给我们。我们也知道，4个人只拉到一个客户确实是令人难堪的成绩。我们并没有多问，选择了沉默。后来我还了解到，那天唯一填了客户登记表的阿姨，她登记的电话居然少了一位。。。好事多磨终成事, 佳期难得自有期。 电玩城兼职待续。。 苏轼广博实验室实习待续。。 未完待续。。。看我如何讲述我的人生","link":"/about/index.html"}],"posts":[{"title":"开端","text":"现在是2022年4月19日20：27，我在宿舍，熊哥依旧在看抖音，带师在玩英雄联盟，东哥在玩魔兽世界，记录一下人生中第一个博客网站的搭建完成及上线。 关于本站使用基于node.js的轻量级博客框架hexo搭建，themes采用Icarus 关于个人现大三软件工程，方向前端，喜欢混科技圈，热爱计算机各种技术深爱搞机，拿到第一步手机就开始捣鼓，上初一搞过 MTK 思凯 mrp 格式的 app，还记得*#*#220807#这些神奇的代码，初二用过 s60v5 平台的手机,搞过 sis，sisx 格式的签名破解，上初三拿到第一步安卓手机开始捣鼓反编译修改系统，同时开始自学了一点 C 语言跟 java，高二开始自学安卓原生开发，全程都是使用 Aide，中途玩过逆向，tiny等免流，对物联网单片机等都有一些了解，使用过 树莓派、Arduino、Esp8266、ch-08 等单片机开发板，独立开发了一个简单的遥控车，对 ch340x，cp210x 等驱动有一定的了解，现致力于Vue，React，Echarts等前端框架的学习，以及个人的开源与上线个人站点。 总结:前端，后端，移动客户端，产品，UI，都在学，除前端外其他基本全是野路子。 我的照片高中 大学 未完待续。。。","link":"/2022/04/19/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"测试","text":"下载测试 点此下载","link":"/2022/04/20/%E6%B5%8B%E8%AF%95/"},{"title":"四级冲刺.4.20.1","text":"1. pretend cherish what if scream approve betray regard identify interview inch period hint tear 接受 识别 暗示 2. penetrate complicated cruel commom sense absorb endlessly equivalent intact ordinary bet raw ripe smooth 穿过 3. trick slap pressure donate version expose attack optimistic battrey mood moral custom domestic 压力 暴露 道德 习俗","link":"/2022/04/20/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA/"},{"title":"四级冲刺.4.20.2","text":"1. obey force fate confuse liar quarrel report fairy wage propose phenomenon blind status 强迫 武力 命运 争吵 提议 求婚 2. refuse cant help doing yield blunt turn out to be accelerator/brake hesitate territory bend religion demand deceive tide 屈服 原来是 领土 欺骗 潮 3. infect standard rarely proof opposite tight disgust prescribe illusion oval poison get stuck frost 传染 证据 开药 椭圆 上当 霜冻","link":"/2022/04/20/4-20-2/"},{"title":"什么是webpack？","text":"从本质上来讲，webpac是一个现代的JavaScript应用的静态打包工具。从两个点来解释上面这句话：模块和打包。 对于一个完整的项目，相关的文件一定不止只有简单的html，css，js文件，不可能一次性的直接将所有文件放在服务器上，此时需要对这些文件进行统一的打包，解析。我们在通过模块化开发完成项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。webpack其中一项功能就是处理模块间的各种依赖关系。 什么是模块化？1.ES6写法在a文件导出1234567891011121314var name = '小明';var age = 18;var flag = true;function sum(num1, num2) { console.log(num1+num2);}if (flag) { sum(20,30)}export { flag, sum} 在b文件导入123456import { flag,sum } from &quot;./aaa.js&quot;;if (flag) { console.log('flag接受到了'); console.log(sum(1,3));} 2.CommonJS写法在a文件导出1234567891011function add(num1,num2) { return(num1+num2)}function mul(num1,num2) { return num1*num2}module.exports = { add, mul} 在b文件导入1234const { add, mul } = require('./mathtools.js')console.log(add(1, 2));console.log(mul(1, 2)); 打包如何理解？就是将webpack中各种资源模块进行打包合并成一个或多个包。在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转换成css，将typescript转换成JavaScript等操作。 怎么使用webpack？在控制台输入命令webpack ./src/main.js ./dist/main.js 进阶用法1.新建配置文件 webpack.config.js在通过npm init新建包管理文件package.json在webpack.config.js下配置如下代码 12345678const path=require('path')module.exports = { entry: './src/main.js', //入口 output: { path: path.resolve(__dirname, 'dist'), //__dirname来自node环境自带path包，是读取当前路径功能（这也是现在需要包管理文件的原因），resolve这个api是用于字符串拼接 filename:'main.js' //出口 }} 这样后直接运行webpack，便能根据配置文件自动去生成。 2.在包管理文件的&quot;scripts&quot;的这个对象，写下&quot;build&quot;: &quot;webpack&quot;这样在终端输入npm run build也可以，并且这样还会首先去找局部的包，而不是全局的。","link":"/2022/04/22/webpack/"},{"title":"四级冲刺.4.22.1","text":"1. deliberate ideal efficient burst stationary blur shave fossil cautions passion horrible whistle pet sharp wonderful 静止的 激情的","link":"/2022/04/22/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-4-22-1/"},{"title":"四级冲刺.4.26.1","text":"1. roar pause strengths massage deposit terrify disturb satisfy landlady instrument delusion upright show off towel 押金/存款 毛巾","link":"/2022/04/26/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-4-26-1/"},{"title":"四级冲刺.4.27.1","text":"1. vaccinate polite pregnant tighten navigation red envelope capable parade detect reunion bushy dissatisfy prompt inspect piggy bank fertile plug 阅兵 提示/促使 检查 能生育的/肥沃","link":"/2022/04/27/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-4-27-1/"},{"title":"supermall项目开发","text":"1.划分目录结构当你通过脚手架搭建完项目框架后，第一件需要做的就是划分目录结构，这是一个需要养成的良好习惯，通常我们只会在src文件夹里面划分。除了默认的components和assets文件夹我们需要添加network文件夹，在其中开发我们所有网络请求的代码；添加router文件夹，里面是我们和路由跳转相关的代码；添加store文件夹，在里面开发复杂组件间数据通讯的Vuex代码；添加views文件夹，这是","link":"/2022/05/02/supermall%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"title":"四级冲刺.5.4.1","text":"1. encounter tease slice bark excess vibrate injure bounce recommend in the act costume imitate conceal resist 取笑 振动 模仿 掩饰 反抗","link":"/2022/05/04/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-5-4-1/"},{"title":"四级冲刺.5.4.2","text":"1. cube deliver dial duration collapse logic vessel spray measure plough rhythm harmony instruct superb endure 喷洒 忍受 2. lamb succession grant beverage 授予/同意","link":"/2022/05/04/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-5-4-2/"},{"title":"Node.js.5.12.2","text":"3. path 路径模块3.1 什么是 path 路径模块path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。例如： path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串 path.basename() 方法，用来从路径字符串中，将文件名解析出来如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：1const path = require('path') 3.2 路径拼接 path.join() 的语法格式使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：1path.join([ . . .paths]) 参数解读： …paths 路径片段的序列 返回值: path.join() 的代码示例12345678const path = require('path')const fs = require('fs')// 注意： ../ 会抵消前面的路径const pathStr = path.join('/a', '/b/c', '../../', './d', 'e')console.log(pathStr) // \\a\\b\\d\\efs.readFile(__dirname + '/files/1.txt') 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：注意：今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。 3.3 获取路径中的文件名 path.basename() 的语法格式使用 path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：1path.basename(path[ , ext]) 参数解读： path 必选参数，表示一个路径的字符串 ext 可选参数，表示文件扩展名 返回: 表示路径中的最后一部分 path.basename() 的代码示例使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分：12345678910const path = require('path')// 定义文件的存放路径const fpath = '/a/b/c/index.html'// const fullName = path.basename(fpath)// console.log(fullName)const nameWithoutExt = path.basename(fpath, '.html')console.log(nameWithoutExt) 3.4 获取路径中的文件扩展名 path.extname() 的语法格式使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下：1path.extname(path) 参数解读： path 必选参数，表示一个路径的字符串 返回: 返回得到的扩展名字符串 path.extname() 的代码示例使用 path.extname() 方法，可以获取路径中的扩展名部分：1234567const path = require('path')// 这是文件的存放路径const fpath = '/a/b/c/index.html'const fext = path.extname(fpath)console.log(fext) 3.5 综合案例 - 时钟案例 案例要实现的功能将素材目录下的 index.html 页面，拆分成三个文件，分别是： index.css index.js index.html并且将拆分出来的 3 个文件，存放到 clock 目录中。 案例的实现步骤① 创建两个正则表达式，分别用来匹配 style 和 script 标签② 使用 fs 模块，读取需要被处理的 HTML 文件③ 自定义 resolveCSS 方法，来写入 index.css 样式文件④ 自定义 resolveJS 方法，来写入 index.js 脚本文件⑤ 自定义 resolveHTML 方法，来写入 index.html 文件 步骤1 - 导入需要的模块并创建正则表达式12345678// 1.1 导入 fs 模块const fs = require('fs')// 1.2 导入 path 模块const path = require('path')// 1.3 定义正则表达式，分别匹配 &lt;style&gt;&lt;/style&gt; 和 &lt;script&gt;&lt;/script&gt; 标签const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;/ 步骤2 - 使用 fs 模块读取需要被处理的 html 文件12345678fs.readFile(path.join(__dirname, '../素材/index.html'), 'utf8', function(err, dataStr) { // 2.2 读取 HTML 文件失败 if (err) return console.log('读取HTML文件失败！' + err.message) // 2.3 读取文件成功后，调用对应的三个方法，分别拆解出 css, js, html 文件 resolveCSS(dataStr) resolveJS(dataStr) resolveHTML(dataStr)}) 步骤3 – 自定义 resolveCSS 方法123456789101112// 3.1 定义处理 css 样式的方法function resolveCSS(htmlStr) { // 3.2 使用正则提取需要的内容 const r1 = regStyle.exec(htmlStr) // 3.3 将提取出来的样式字符串，进行字符串的 replace 替换操作 const newCSS = r1[0].replace('&lt;style&gt;', '').replace('&lt;/style&gt;', '') // 3.4 调用 fs.writeFile() 方法，将提取的样式，写入到 clock 目录中 index.css 的文件里面 fs.writeFile(path.join(__dirname, './clock/index.css'), newCSS, function(err) { if (err) return console.log('写入 CSS 样式失败！' + err.message) console.log('写入样式文件成功！') })} 步骤4 – 自定义 resolveJS 方法123456789101112// 4.1 定义处理 js 脚本的方法function resolveJS(htmlStr) { // 4.2 通过正则，提取对应的 &lt;script&gt;&lt;/script&gt; 标签内容 const r2 = regScript.exec(htmlStr) // 4.3 将提取出来的内容，做进一步的处理 const newJS = r2[0].replace('&lt;script&gt;', '').replace('&lt;/script&gt;', '') // 4.4 将处理的结果，写入到 clock 目录中的 index.js 文件里面 fs.writeFile(path.join(__dirname, './clock/index.js'), newJS, function(err) { if (err) return console.log('写入 JavaScript 脚本失败！' + err.message) console.log('写入 JS 脚本成功！') })} 步骤5 – 自定义 resolveHTML 方法12345678910// 5.1 定义处理 HTML 结构的方法function resolveHTML(htmlStr) { // 5.2 将字符串调用 replace 方法，把内嵌的 style 和 script 标签，替换为外联的 link 和 script 标签 const newHTML = htmlStr.replace(regStyle, '&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; /&gt;').replace(regScript, '&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;') // 5.3 写入 index.html 这个文件 fs.writeFile(path.join(__dirname, './clock/index.html'), newHTML, function(err) { if (err) return console.log('写入 HTML 文件失败！' + err.message) console.log('写入 HTML 页面成功！') })} 4. 案例的两个注意点① fs.writeFile() 方法只能用来创建文件，不能用来创建路径② 重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容","link":"/2022/05/12/Node-js-5-12-2/"},{"title":"Node.js.5.12.3","text":"4. http 模块4.1 什么是 http 模块回顾：什么是客户端、什么是服务器？在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。如果要希望使用 http 模块创建 Web 服务器，则需要先导入它： 1const http -require( &quot; http ') 4.2 进一步理解 http 模块的作用服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务。 4.3 服务器相关的概念 IP 地址IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）注意：① 互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。② 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP 地址，就能把自己的电脑当做一台服务器进行访问了。 域名和域名服务器尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。 注意：① 单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。② 在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。3. 端口号计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。注意：① 每个端口号不能同时被多个 web 服务占用。② 在实际应用中，URL 中的 80 端口可以被省略。 4.4 创建最基本的 web 服务器 创建 web 服务器的基本步骤① 导入 http 模块② 创建 web 服务器实例③ 为服务器实例绑定 request 事件，监听客户端的请求④ 启动服务器 步骤1 - 导入 http 模块如果希望在自己的电脑上创建一个 web 服务器，从而对外提供 web 服务，则需要导入 http 模块：1const http = require('http') 步骤2 - 创建 web 服务器实例调用 http.createServer() 方法，即可快速创建一个 web 服务器实例：const server = http.createServer() 步骤3 - 为服务器实例绑定 request 事件为服务器实例绑定 request 事件，即可监听客户端发送过来的网络请求：1234// 3. 为服务器实例绑定 request 事件，监听客户端的请求server.on('request', function (req, res) { console.log('Someone visit our web server.')}) 步骤4 - 启动服务器调用服务器实例的 .listen() 方法，即可启动当前的 web 服务器实例：1234// 4. 启动服务器server.listen(8080, function () { console.log('server running at http://127.0.0.1:8080')}) req 请求对象只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式：12345678910111213141516const http = require('http')const server = http.createServer()// req 是请求对象，包含了与客户端相关的数据和属性server.on('request', (req, res) =&gt; { // req.url 是客户端请求的 URL 地址 const url = req.url // req.method 是客户端请求的 method 类型 const method = req.method const str = `Your request url is ${url}, and request method is ${method}` console.log(str) // 调用 res.end() 方法，向客户端响应一些内容 res.end(str)})server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1')}) res 响应对象在服务器的 request 事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式：123456789101112131415const http = require('http')const server = http.createServer()server.on('request', (req, res) =&gt; { // 定义一个字符串，包含中文的内容 const str = `您请求的 URL 地址是 ${req.url}，请求的 method 类型为 ${req.method}` // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题 res.setHeader('Content-Type', 'text/html; charset=utf-8') // res.end() 将内容响应给客户端 res.end(str)})server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1')}) 4.5 根据不同的 url 响应不同的 html 内容 核心实现步骤① 获取请求的 url 地址② 设置默认的响应内容为 404 Not found③ 判断用户请求的是否为 / 或 /index.html 首页④ 判断用户请求的是否为 /about.html 关于页面⑤ 设置 Content-Type 响应头，防止中文乱码⑥ 使用 res.end() 把内容响应给客户端 动态响应内容123456789101112131415161718192021222324const http = require('http')const server = http.createServer()server.on('request', (req, res) =&gt; { // 1. 获取请求的 url 地址 const url = req.url // 2. 设置默认的响应内容为 404 Not found let content = '&lt;h1&gt;404 Not found!&lt;/h1&gt;' // 3. 判断用户请求的是否为 / 或 /index.html 首页 // 4. 判断用户请求的是否为 /about.html 关于页面 if (url === '/' || url === '/index.html') { content = '&lt;h1&gt;首页&lt;/h1&gt;' } else if (url === '/about.html') { content = '&lt;h1&gt;关于页面&lt;/h1&gt;' } // 5. 设置 Content-Type 响应头，防止中文乱码 res.setHeader('Content-Type', 'text/html; charset=utf-8') // 6. 使用 res.end() 把内容响应给客户端 res.end(content)})server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1')}) 4.6 案例 - 实现 clock 时钟的 web 服务器 核心思路把文件的实际存放路径，作为每个资源的请求 url 地址。 实现步骤① 导入需要的模块② 创建基本的 web 服务器③ 将资源的请求 url 地址映射为文件的存放路径④ 读取文件内容并响应给客户端⑤ 优化资源的请求路径 步骤1 - 导入需要的模块123456// 1.1 导入 http 模块const http = require('http')// 1.2 导入 fs 模块const fs = require('fs')// 1.3 导入 path 模块const path = require('path') 步骤2 - 创建基本的 web 服务器123456789101112131415161718192021222324252627282930313233343536373839404142// 1.1 导入 http 模块const http = require('http')// 1.2 导入 fs 模块const fs = require('fs')// 1.3 导入 path 模块const path = require('path')// 2.1 创建 web 服务器const server = http.createServer()// 2.2 监听 web 服务器的 request 事件server.on('request', (req, res) =&gt; { // 3.1 获取到客户端请求的 URL 地址 // /clock/index.html // /clock/index.css // /clock/index.js const url = req.url // 3.2 把请求的 URL 地址映射为具体文件的存放路径 // const fpath = path.join(__dirname, url) // 5.1 预定义一个空白的文件存放路径 let fpath = '' if (url === '/') { fpath = path.join(__dirname, './clock/index.html') } else { // /index.html // /index.css // /index.js fpath = path.join(__dirname, '/clock', url) } // 4.1 根据“映射”过来的文件路径读取文件的内容 fs.readFile(fpath, 'utf8', (err, dataStr) =&gt; { // 4.2 读取失败，向客户端响应固定的“错误消息” if (err) return res.end('404 Not found.') // 4.3 读取成功，将读取成功的内容，响应给客户端 res.end(dataStr) })})// 2.3 启动服务器server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1')})","link":"/2022/05/12/Node-js-5-12-3/"},{"title":"Node.js.5.12.1","text":"2.fs 文件系统模块2.1 什么是 fs 文件系统模块fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如： fs.readFile() 方法，用来读取指定文件中的内容 fs.writeFile() 方法，用来向指定的文件中写入内容如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：12const fs =require( 'fs ')--- 2.2 读取指定文件中的内容 fs.readFile() 的语法格式使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下：1fs.readFile(path[, options], callback) 参数解读： 参数1：必选参数，字符串，表示文件的路径。 参数2：可选参数，表示以什么编码格式来读取文件。 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。 fs.readFile() 的示例代码以 utf8 的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值：12345const fs = require('fs')fs.readFile('../code/files/1.txt', 'utf8', (err, data_str) =&gt; { console.log(err); console.log(data_str);}) 判断文件是否读取成功可以判断 err 对象是否为 null，从而知晓文件读取的结果：12345const fs = require( 'fs ')fs.readFile( ' .ifiles/1.txt&quot;,'utf8&quot;, function(err, result) { if (err) {return console.log('文件读取失败! ' + err.message)}console.log('文件读取成功,内容是:' t result)}) 2.3 向指定的文件中写入内容 fs.writeFile() 的语法格式使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：参数解读：1fs.writeFile(file, data[, options], callback) 参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。 参数2：必选参数，表示要写入的内容。 参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。 参数4：必选参数，文件写入完成后的回调函数。 fs.writeFile() 的示例代码向指定的文件路径中，写入文件内容：1234const fs = require('fs')fs.writeFile(&quot;../code/files/1.txt&quot;, 'hello Node.js', err =&gt; { console.log(err);}) 判断文件是否写入成功可以判断 err 对象是否为 null，从而知晓文件写入的结果：12345678const fs = require('fs')fs.readFile('./files/11.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)}) 2.5 练习 - 考试成绩整理使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。核心实现步骤① 导入需要的 fs 文件系统模块② 使用 fs.readFile() 方法，读取素材目录下的 成绩.txt 文件③ 判断文件是否读取失败④ 文件读取成功后，处理成绩数据⑤ 将处理完成的成绩数据，调用 fs.writeFile() 方法，写入到新文件 成绩-ok.txt 中 1234567891011121314151617181920212223242526272829// 1. 导入 fs 模块const fs = require('fs')// 2. 调用 fs.readFile() 读取文件的内容fs.readFile('../素材/成绩.txt', 'utf8', function(err, dataStr) { // 3. 判断是否读取成功 if (err) { return console.log('读取文件失败！' + err.message) } // console.log('读取文件成功！' + dataStr) // 4.1 先把成绩的数据，按照空格进行分割 const arrOld = dataStr.split(' ') // 4.2 循环分割后的数组，对每一项数据，进行字符串的替换操作 const arrNew = [] arrOld.forEach(item =&gt; { arrNew.push(item.replace('=', '：')) }) // 4.3 把新数组中的每一项，进行合并，得到一个新的字符串 const newStr = arrNew.join('\\r\\n') // 5. 调用 fs.writeFile() 方法，把处理完毕的成绩，写入到新文件中 fs.writeFile('./files/成绩-ok.txt', newStr, function(err) { if (err) { return console.log('写入文件失败！' + err.message) } console.log('成绩写入成功！') })}) 2.6 fs 模块 - 路径动态拼接的问题在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。 1234567891011121314151617181920212223242526272829const fs = require('fs')// 出现路径拼接错误的问题，是因为提供了 ./ 或 ../ 开头的相对路径// 如果要解决这个问题，可以直接提供一个完整的文件存放路径就行/* fs.readFile('./files/1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)}) */// 移植性非常差、不利于维护/* fs.readFile('C:\\\\Users\\\\escook\\\\Desktop\\\\Node.js基础\\\\day1\\\\code\\\\files\\\\1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)}) */// __dirname 表示当前文件所处的目录// console.log(__dirname)fs.readFile(__dirname + '/files/1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)})","link":"/2022/05/12/Node-js-5-12-1/"},{"title":"Node.js.5.13.1","text":"1. 模块化的基本概念1.1 什么是模块化 现实生活中的模块化 编程领域中的模块化编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。把代码进行模块化拆分的好处：① 提高了代码的复用性② 提高了代码的可维护性③ 可以实现按需加载 1.2 模块化规范模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。例如： 使用什么样的语法格式来引用模块 在模块中使用什么样的语法格式向外暴露成员模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。 2. Node.js 中的模块化2.1 Node.js 中模块的分类Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是： 内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） 自定义模块（用户创建的每个 .js 文件，都是自定义模块） 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载） 2.2 加载模块使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如： 123456// 1．加载内置的fs 模块const fs = require( &quot;fs ')// 2．加载用户的自定义模块const custom = require( ' ./ custom.js ')// 3.加载第三方模块(关于第三方模块的下载和使用，会在后面的课程中进行专门 的讲解)const moment = require( &quot; moment ' ) 注意：使用 require() 方法加载其它模块时，会执行被加载模块中的代码。 2.3 Node.js 中的模块作用域 什么是模块作用域和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。 模块作用域的好处防止了全局变量污染的问题 2.4 向外共享模块作用域中的成员 module 对象在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下： Module { id: ‘.’, path: ‘C:\\Users\\ceaser\\Desktop\\up_station\\node.js—资料\\day2\\code’, exports: {}, filename: ‘C:\\Users\\ceaser\\Desktop\\up_station\\node.js—资料\\day2\\code\\10.演示module对象.js’, loaded: false, children: [], paths: [ ‘C:\\Users\\ceaser\\Desktop\\up_station\\node.js—资料\\day2\\code\\node_modules’, ‘C:\\Users\\ceaser\\Desktop\\up_station\\node.js—资料\\day2\\node_modules’, ‘C:\\Users\\ceaser\\Desktop\\up_station\\node.js—资料\\node_modules’, ‘C:\\Users\\ceaser\\Desktop\\up_station\\node_modules’, ‘C:\\Users\\ceaser\\Desktop\\node_modules’, ‘C:\\Users\\ceaser\\node_modules’, ‘C:\\Users\\node_modules’, ‘C:\\node_modules’ ]} module.exports 对象在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象 共享成员时的注意点使用 require() 方法导入模块时，导入的结果，永远以 module.exports 指向的对象为准。1234567891011121314// console.log(exports)// console.log(module.exports)// console.log(exports === module.exports)const username = 'zs'module.exports.username = usernameexports.age = 20exports.sayHello = function() { console.log('大家好！')}// 最终，向外共享的结果，永远都是 module.exports 所指向的对象 exports 对象由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。 exports 和 module.exports 的使用误区时刻谨记，require() 模块时，得到的永远是 module.exports 指向的对象 3. npm与包3.1 包 什么是包Node.js 中的第三方模块又叫做包。就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。 包的来源不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。注意：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。 为什么需要包由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系。 从哪里下载包国外有一家 IT 公司，叫做 npm, Inc. 这家公司旗下有一个非常著名的网站： https://www.npmjs.com/ ，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！到目前位置，全球约 1100 多万的开发人员，通过这个包共享平台，开发并共享了超过 120 多万个包 供我们使用。npm, Inc. 公司提供了一个地址为 https://registry.npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。注意： 从 https://www.npmjs.com/ 网站上搜索自己所需要的包 从 https://registry.npmjs.org/ 服务器上下载自己需要的包 如何下载包npm, Inc. 公司提供了一个包管理工具，我们可以使用这个包管理工具，从 https://registry.npmjs.org/ 服务器把需要的包下载到本地使用。这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。大家可以在终端中执行 npm -v 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号： 3.2 npm 初体验 格式化时间的传统做法① 创建格式化时间的自定义模块② 定义格式化时间的方法③ 创建补零函数④ 从自定义模块中导出格式化时间的函数⑤ 导入格式化时间的自定义模块⑥ 调用格式化时间的函数12345678910111213141516171819202122232425262728293031// 1. 定义格式化时间的方法function dateFormat(dtStr) { const dt = new Date(dtStr) const y = dt.getFullYear() const m = padZero(dt.getMonth() + 1) const d = padZero(dt.getDate()) const hh = padZero(dt.getHours()) const mm = padZero(dt.getMinutes()) const ss = padZero(dt.getSeconds()) return `${y}-${m}-${d} ${hh}:${mm}:${ss}`}// 定义补零的函数function padZero(n) { return n &gt; 9 ? n : '0' + n}module.exports = { dateFormat}const TIME = require('./15.dateFormat')// 调用方法，进行时间的格式化const dt = new Date()// console.log(dt)const newDT = TIME.dateFormat(dt)console.log(newDT) 格式化时间的高级做法① 使用 npm 包管理工具，在项目中安装格式化时间的包 moment② 使用 require() 导入格式化时间的包③ 参考 moment 的官方 API 文档对时间进行格式化123456// 1. 导入需要的包// 注意：导入的名称，就是装包时候的名称const moment = require('moment')const dt = moment().format('YYYY-MM-DD HH:mm:ss')console.log(dt) 初次装包后多了哪些文件初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。其中：node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。 安装指定版本的包默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本，例如： 包的语义化版本规范包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0其中每一位数字所代表的的含义如下：第1位数字：大版本第2位数字：功能版本第3位数字：Bug修复版本版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。 3.3 包管理配置文件npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息。例如： 项目的名称、版本号、描述等 项目中都用到了哪些包 哪些包只在开发期间会用到 那些包在开发和部署时都需要用到 多人协作的问题整个项目的体积是 30.4M第三方包的体积是 28.8M项目源代码的体积 1.6M遇到的问题：第三方包的体积过大，不方便团队成员之间共享项目源代码。解决方案：共享时剔除node_module 如何记录项目中安装了哪些包在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后，在团队成员之间共享项目的源代码。注意：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。 快速创建 package.jsonnpm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件：npm init -y注意：① 上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。② 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。 dependencies 节点package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install命令安装了哪些包。 一次性安装所有的包当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。否则会报类似于下面的错误： 一次性安装所有的包可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包： 卸载包可以运行 npm uninstall 命令，来卸载指定的包：注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。 devDependencies 节点如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。您可以使用如下的命令，将包记录到 devDependencies 节点中： 3.5 包的分类 项目包那些被安装到项目的 node_modules 目录中的包，都是项目包。项目包又分为两类，分别是： 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到） 核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到） 全局包在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。全局包会被安装到 C:\\Users\\用户目录\\AppData\\Roaming\\npm\\node_modules 目录下。注意：① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。 3.6 规范的包结构在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。一个规范的包，它的组成结构，必须符合以下 3 点要求：① 包必须以单独的目录而存在② 包的顶级目录下要必须包含 package.json 这个包管理配置文件③ package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：https://yarnpkg.com/zh-Hans/docs/package-json","link":"/2022/05/13/Node-js-5-13-1/"},{"title":"Node.js.5.13.2","text":"1. 初识 Express1.1 Express 简介 什么是 Express官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。Express 的中文官网： http://www.expressjs.com.cn/ 进一步理解 Express思考：不使用 Express 能否创建 Web 服务器？答案：能，使用 Node.js 提供的原生 http 模块即可。思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。思考：http 内置模块与 Express 是什么关系？答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。 Express 能做什么对于前端程序员来说，最常见的两种服务器，分别是： Web 网站服务器：专门对外提供 Web 网页资源的服务器。 API 接口服务器：专门对外提供 API 接口的服务器。使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。 1.2 Express 的基本使用 安装在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用：1npm i express@4.17.1 创建基本的 Web 服务器12345678// 1. 导入 expressconst express = require('express')// 2. 创建 web 服务器const app = express()// 3. 启动 web 服务器app.listen(80, () =&gt; { console.log('express server running at http://127.0.0.1')}) 监听 GET 请求通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下：通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下：通过 res.send() 方法，可以把处理好的内容，发送给客户端： 123456789// 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容app.get('/user', (req, res) =&gt; { // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象 res.send({ name: 'zs', age: 20, gender: '男' })})app.post('/user', (req, res) =&gt; { // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串 res.send('请求成功')}) 获取 URL 中携带的查询参数通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：123456app.get('/', (req, res) =&gt; { // 通过 req.query 可以获取到客户端发送过来的 查询参数 // 注意：默认情况下，req.query 是一个空对象 console.log(req.query) res.send(req.query)}) 获取 URL 中的动态参数通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数：123456// 注意：这里的 :id 是一个动态的参数app.get('/user/:ids/:username', (req, res) =&gt; { // req.params 是动态匹配到的 URL 参数，默认也是一个空对象 console.log(req.params) res.send(req.params)}) 1.3 托管静态资源 express.static()express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：12345678910const express = require('express')const app = express()// 在这里，调用 express.static() 方法，快速的对外提供静态资源app.use('/files', express.static('./files'))app.use(express.static('./clock'))app.listen(80, () =&gt; { console.log('express server running at http://127.0.0.1')}) 现在，你就可以访问 public 目录中的所有文件了：http://localhost:3000/images/bg.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/login.js注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。 托管多个静态资源目录如果要托管多个静态资源目录，请多次调用 express.static() 函数：访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。 挂载路径前缀如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：1app.use('/public', express.static('./public')) 现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：http://localhost:3000/public/images/kitten.jpghttp://localhost:3000/public/css/style.csshttp://localhost:3000/public/js/app.js 2.1 路由的概念1. 什么是路由广义上来讲，路由就是映射关系。3. Express 中的路由在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下： 1234567891011121314const express = require('express')const app = express()// 挂载路由app.get('/', (req, res) =&gt; { res.send('hello world.')})app.post('/', (req, res) =&gt; { res.send('Post Request.')})app.listen(80, () =&gt; { console.log('http://127.0.0.1')}) 路由的匹配过程每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。路由匹配的注意点：① 按照定义的先后顺序进行匹配② 请求类型和请求的URL同时匹配成功，才会调用对应的处理函数 2.2 路由的使用 最简单的用法在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下： 2.2 路由的使用 最简单的用法在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：1234567891011121314const express = require('express')const app = express()// 挂载路由app.get('/', (req, res) =&gt; { res.send('hello world.')})app.post('/', (req, res) =&gt; { res.send('Post Request.')})app.listen(80, () =&gt; { console.log('http://127.0.0.1')}) 模块化路由为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：① 创建路由模块对应的 .js 文件② 调用 express.Router() 函数创建路由对象③ 向路由对象上挂载具体的路由④ 使用 module.exports 向外共享路由对象⑤ 使用 app.use() 函数注册路由模块 创建路由模块12345678910111213141516// 这是路由模块// 1. 导入 expressconst express = require('express')// 2. 创建路由对象const router = express.Router()// 3. 挂载具体的路由router.get('/user/list', (req, res) =&gt; { res.send('Get user list.')})router.post('/user/add', (req, res) =&gt; { res.send('Add new user.')})// 4. 向外导出路由对象module.exports = router 注册路由模块123456789101112131415const express = require('express')const app = express()// app.use('/files', express.static('./files'))// 1. 导入路由模块const router = require('./03.router')// 2. 注册路由模块app.use('/api', router)// 注意： app.use() 函数的作用，就是来注册全局中间件app.listen(80, () =&gt; { console.log('http://127.0.0.1')}) 为路由模块添加前缀类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：12app.use(router)app.use('/api', router) 3.1 中间件的概念 什么是中间件中间件（Middleware ），特指业务流程的中间处理环节。 现实生活中的例子在处理污水的时候，一般都要经过三个处理环节，从而保证处理过后的废水，达到排放标准。处理污水的这三个中间处理环节，就可以叫做中间件。 Express 中间件的调用流程当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。 Express 中间件的格式Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。 next 函数的作用next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。 3.2 Express 中间件的初体验 定义中间件函数可以通过如下的方式，定义一个最简单的中间件函数：123456789const express = require('express')const app = express() // 定义一个最简单的中间件函数const mw = function (req, res, next) {console.log('这是最简单的中间件函数')// 把流转关系，转交给下一个中间件或路由next() } 全局生效的中间件客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下：1234// // 将 mw 注册为全局生效的中间件// app.use(mw)// 这是定义全局中间件的简化形式 中间件的作用多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。12345678910111213141516171819202122const express = require('express')const app = express()// 这是定义全局中间件的简化形式app.use((req, res, next) =&gt; { // 获取到请求到达服务器的时间 const time = Date.now() // 为 req 对象，挂载自定义属性，从而把时间共享给后面的所有路由 req.startTime = time next()})app.get('/', (req, res) =&gt; { res.send('Home page.' + req.startTime)})app.get('/user', (req, res) =&gt; { res.send('User page.' + req.startTime)})app.listen(80, () =&gt; { console.log('http://127.0.0.1')}) 定义多个全局中间件可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：12345678910111213141516171819202122const express = require('express')const app = express()// 定义第一个全局中间件app.use((req, res, next) =&gt; { console.log('调用了第1个全局中间件') next()})// 定义第二个全局中间件app.use((req, res, next) =&gt; { console.log('调用了第2个全局中间件') next()})// 定义一个路由app.get('/user', (req, res) =&gt; { res.send('User page.')})app.listen(80, () =&gt; { console.log('http://127.0.0.1')}) 局部生效的中间件不使用 app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下：1234567891011121314151617181920212223// 导入 express 模块const express = require('express')// 创建 express 的服务器实例const app = express()// 1. 定义中间件函数const mw1 = (req, res, next) =&gt; { console.log('调用了局部生效的中间件') next()}// 2. 创建路由app.get('/', mw1, (req, res) =&gt; { res.send('Home page.')})app.get('/user', (req, res) =&gt; { res.send('User page.')})// 调用 app.listen 方法，指定端口号并启动web服务器app.listen(80, function () { console.log('Express server running at http://127.0.0.1')}) 定义多个局部中间件可以在路由中，通过如下两种等价的方式，使用多个局部中间件：123app.get('/', [mw1, mw2], (req, res) =&gt; { res.send('Home page.')}) 了解中间件的5个使用注意事项① 一定要在路由之前注册中间件② 客户端发送过来的请求，可以连续调用多个中间件进行处理③ 执行完中间件的业务代码之后，不要忘记调用 next() 函数④ 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码⑤ 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象 3.3 中间件的分类为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：① 应用级别的中间件② 路由级别的中间件③ 错误级别的中间件④ Express 内置的中间件⑤ 第三方的中间件","link":"/2022/05/13/Node-js-5-13-2/"}],"tags":[{"name":"CET4","slug":"CET4","link":"/tags/CET4/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"复习","slug":"复习","link":"/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Express","slug":"Express","link":"/tags/Express/"}],"categories":[{"name":"英语","slug":"英语","link":"/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"项目开发","slug":"项目开发","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"},{"name":"Express","slug":"Express","link":"/categories/Express/"}]}