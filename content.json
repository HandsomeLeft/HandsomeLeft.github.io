{"pages":[{"title":"关于","text":"关于本站使用基于node.js的轻量级博客框架hexo搭建，themes采用Icarus 关于个人现大三软件工程，方向前端，喜欢混科技圈，热爱计算机各种技术深爱搞机，拿到第一步手机就开始捣鼓，上初一搞过 MTK 思凯 mrp 格式的 app，还记得*#*#220807#这些神奇的代码，初二用过 s60v5 平台的手机,搞过 sis，sisx 格式的签名破解，上初三拿到第一步安卓手机开始捣鼓反编译修改系统，同时开始自学了一点 C 语言跟 java，高二开始自学安卓原生开发，全程都是使用 Aide，中途玩过逆向，tiny等免流，对物联网单片机等都有一些了解，使用过 树莓派、Arduino、Esp8266、ch-08 等单片机开发板，独立开发了一个简单的遥控车，对 ch340x，cp210x 等驱动有一定的了解，现致力于Vue，React，Echarts等前端框架的学习，以及个人的开源与上线个人站点。 总结:前端，后端，移动客户端，产品，UI，都在学，除前端外其他基本全是野路子。 我的照片高中 大学 爱好逃离塔科夫忠实玩家 足球 代码 剧本杀 工作经历截止 2022年4月20日，一共有过三次工作经历，即使目前我参加的所有工作中没有和代码相关的，但也挺有趣于是愿意分享一下。 书法兴趣班那是在大二的暑假，在成都中坝，我和高中的三个兄弟一起策划就地找个工作，想着这样又有工资拿又能一起玩耍，挺好。我们在中坝转了一圈，有游泳班，有补课机构，有健身房，甚至还有在boss上都还在发布招聘公告但我们一去实地需要坐一部藏在深巷里的电梯，电梯门一打开迎面的是一堵水泥墙（墙上写着铺面已转让的告示）这样的阴森饭店。我们因为种种原因都没有被录用，但是在最后一家看起来还不错的少儿书法培训机构愿意去接待我们。接待我们的是一名可能只比我们大几岁的大学学姐。我们是临时录用的，她给我们说只能分配给我们发传单，拉客户的工作。说起发传单，反正我是挺不愿意的，可能是恐惧，害羞，换位思考后我也挺不待见给我发传单的人。但望向丁逼，赵杨朋，刘川。他们三看上去挺有自信，我们最后签了兼职工作的合同，薪酬是15元一小时，她通知我们下周一来上班。到了上班的时间，我早早的赶到了店里，赵杨朋依旧迟到。但还好，学姐并没有责备。她给了我们一张客户登记表，一支笔，一把店里的传单。领我们分别去了商城门口，地铁口，小区大门口。我们的任务就是拉客户！我被分配在了中坝鹏瑞利商场的门口，此刻我充满了自信，但谁呈想到一段艰难的时期来了。面对商城门口的车水马龙，我尽力的往人们的手中递着传单，向带着小朋友的家长介绍着我的业务。但在这充满竞争的社会，没有想象中的敬贤礼士，好言好语，换来的更多是一个白眼，一张冷漠的表情。此刻我的心情来到了冰点。当然也有令人安慰的事情，我遇到了一位阿姨，他知道我是附近书法培训班的。她真的很愿意去帮助我，即使她并没有让自己小孩报名书法培训班的需求，她把她的信息填在了客户登记表上。最后经历了难熬的4小时，我们下班了。他们哥三一个客户也没有拉到，最终我们的战果是4人·一个下午·一名客户。回到店里，我看到学姐的表情已经不对了，她让我们先回去。第二天学姐给我们发了微信，通知说我们不用再来了，第一天的工资月底会发给我们。我们也知道，4个人只拉到一个客户确实是令人难堪的成绩。我们并没有多问，选择了沉默。后来我还了解到，那天唯一填了客户登记表的阿姨，她登记的电话居然少了一位。。。好事多磨终成事, 佳期难得自有期。 电玩城兼职待续。。 苏轼广博实验室实习待续。。 未完待续。。。看我如何讲述我的人生","link":"/about/index.html"}],"posts":[{"title":"开端","text":"现在是2022年4月19日20：27，我在宿舍，熊哥依旧在看抖音，带师在玩英雄联盟，东哥在玩魔兽世界，记录一下人生中第一个博客网站的搭建完成及上线。 关于本站使用基于node.js的轻量级博客框架hexo搭建，themes采用Icarus 关于个人现大三软件工程，方向前端，喜欢混科技圈，热爱计算机各种技术深爱搞机，拿到第一步手机就开始捣鼓，上初一搞过 MTK 思凯 mrp 格式的 app，还记得*#*#220807#这些神奇的代码，初二用过 s60v5 平台的手机,搞过 sis，sisx 格式的签名破解，上初三拿到第一步安卓手机开始捣鼓反编译修改系统，同时开始自学了一点 C 语言跟 java，高二开始自学安卓原生开发，全程都是使用 Aide，中途玩过逆向，tiny等免流，对物联网单片机等都有一些了解，使用过 树莓派、Arduino、Esp8266、ch-08 等单片机开发板，独立开发了一个简单的遥控车，对 ch340x，cp210x 等驱动有一定的了解，现致力于Vue，React，Echarts等前端框架的学习，以及个人的开源与上线个人站点。 总结:前端，后端，移动客户端，产品，UI，都在学，除前端外其他基本全是野路子。 我的照片高中 大学 未完待续。。。","link":"/2022/04/19/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"测试","text":"下载测试 点此下载","link":"/2022/04/20/%E6%B5%8B%E8%AF%95/"},{"title":"四级冲刺.4.20.1","text":"1. pretend cherish what if scream approve betray regard identify interview inch period hint tear 接受 识别 暗示 2. penetrate complicated cruel commom sense absorb endlessly equivalent intact ordinary bet raw ripe smooth 穿过 3. trick slap pressure donate version expose attack optimistic battrey mood moral custom domestic 压力 暴露 道德 习俗","link":"/2022/04/20/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA/"},{"title":"四级冲刺.4.20.2","text":"1. obey force fate confuse liar quarrel report fairy wage propose phenomenon blind status 强迫 武力 命运 争吵 提议 求婚 2. refuse cant help doing yield blunt turn out to be accelerator/brake hesitate territory bend religion demand deceive tide 屈服 原来是 领土 欺骗 潮 3. infect standard rarely proof opposite tight disgust prescribe illusion oval poison get stuck frost 传染 证据 开药 椭圆 上当 霜冻","link":"/2022/04/20/4-20-2/"},{"title":"什么是webpack？","text":"从本质上来讲，webpac是一个现代的JavaScript应用的静态打包工具。从两个点来解释上面这句话：模块和打包。 对于一个完整的项目，相关的文件一定不止只有简单的html，css，js文件，不可能一次性的直接将所有文件放在服务器上，此时需要对这些文件进行统一的打包，解析。我们在通过模块化开发完成项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。webpack其中一项功能就是处理模块间的各种依赖关系。 什么是模块化？1.ES6写法在a文件导出1234567891011121314var name = '小明';var age = 18;var flag = true;function sum(num1, num2) { console.log(num1+num2);}if (flag) { sum(20,30)}export { flag, sum} 在b文件导入123456import { flag,sum } from &quot;./aaa.js&quot;;if (flag) { console.log('flag接受到了'); console.log(sum(1,3));} 2.CommonJS写法在a文件导出1234567891011function add(num1,num2) { return(num1+num2)}function mul(num1,num2) { return num1*num2}module.exports = { add, mul} 在b文件导入1234const { add, mul } = require('./mathtools.js')console.log(add(1, 2));console.log(mul(1, 2)); 打包如何理解？就是将webpack中各种资源模块进行打包合并成一个或多个包。在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转换成css，将typescript转换成JavaScript等操作。 怎么使用webpack？在控制台输入命令webpack ./src/main.js ./dist/main.js 进阶用法1.新建配置文件 webpack.config.js在通过npm init新建包管理文件package.json在webpack.config.js下配置如下代码 12345678const path=require('path')module.exports = { entry: './src/main.js', //入口 output: { path: path.resolve(__dirname, 'dist'), //__dirname来自node环境自带path包，是读取当前路径功能（这也是现在需要包管理文件的原因），resolve这个api是用于字符串拼接 filename:'main.js' //出口 }} 这样后直接运行webpack，便能根据配置文件自动去生成。 2.在包管理文件的&quot;scripts&quot;的这个对象，写下&quot;build&quot;: &quot;webpack&quot;这样在终端输入npm run build也可以，并且这样还会首先去找局部的包，而不是全局的。","link":"/2022/04/22/webpack/"},{"title":"四级冲刺.4.22.1","text":"1. deliberate ideal efficient burst stationary blur shave fossil cautions passion horrible whistle pet sharp wonderful 静止的 激情的","link":"/2022/04/22/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-4-22-1/"},{"title":"四级冲刺.4.26.1","text":"1. roar pause strengths massage deposit terrify disturb satisfy landlady instrument delusion upright show off towel 押金/存款 毛巾","link":"/2022/04/26/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-4-26-1/"},{"title":"四级冲刺.4.27.1","text":"1. vaccinate polite pregnant tighten navigation red envelope capable parade detect reunion bushy dissatisfy prompt inspect piggy bank fertile plug 阅兵 提示/促使 检查 能生育的/肥沃","link":"/2022/04/27/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-4-27-1/"},{"title":"supermall项目开发","text":"1.划分目录结构当你通过脚手架搭建完项目框架后，第一件需要做的就是划分目录结构，这是一个需要养成的良好习惯，通常我们只会在src文件夹里面划分。除了默认的components和assets文件夹我们需要添加network文件夹，在其中开发我们所有网络请求的代码；添加router文件夹，里面是我们和路由跳转相关的代码；添加store文件夹，在里面开发复杂组件间数据通讯的Vuex代码；添加views文件夹，这是","link":"/2022/05/02/supermall%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"title":"四级冲刺.5.4.1","text":"1. encounter tease slice bark excess vibrate injure bounce recommend in the act costume imitate conceal resist 取笑 振动 模仿 掩饰 反抗","link":"/2022/05/04/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-5-4-1/"},{"title":"四级冲刺.5.4.2","text":"1. cube deliver dial duration collapse logic vessel spray measure plough rhythm harmony instruct superb endure 喷洒 忍受 2. lamb succession grant beverage 授予/同意","link":"/2022/05/04/%E5%9B%9B%E7%BA%A7%E5%86%B2%E5%88%BA-5-4-2/"},{"title":"Node.js.5.12.2","text":"3. path 路径模块3.1 什么是 path 路径模块path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。例如： path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串 path.basename() 方法，用来从路径字符串中，将文件名解析出来如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：1const path = require('path') 3.2 路径拼接 path.join() 的语法格式使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：1path.join([ . . .paths]) 参数解读： …paths 路径片段的序列 返回值: path.join() 的代码示例12345678const path = require('path')const fs = require('fs')// 注意： ../ 会抵消前面的路径const pathStr = path.join('/a', '/b/c', '../../', './d', 'e')console.log(pathStr) // \\a\\b\\d\\efs.readFile(__dirname + '/files/1.txt') 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：注意：今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。 3.3 获取路径中的文件名 path.basename() 的语法格式使用 path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：1path.basename(path[ , ext]) 参数解读： path 必选参数，表示一个路径的字符串 ext 可选参数，表示文件扩展名 返回: 表示路径中的最后一部分 path.basename() 的代码示例使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分：12345678910const path = require('path')// 定义文件的存放路径const fpath = '/a/b/c/index.html'// const fullName = path.basename(fpath)// console.log(fullName)const nameWithoutExt = path.basename(fpath, '.html')console.log(nameWithoutExt) 3.4 获取路径中的文件扩展名 path.extname() 的语法格式使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下：1path.extname(path) 参数解读： path 必选参数，表示一个路径的字符串 返回: 返回得到的扩展名字符串 path.extname() 的代码示例使用 path.extname() 方法，可以获取路径中的扩展名部分：1234567const path = require('path')// 这是文件的存放路径const fpath = '/a/b/c/index.html'const fext = path.extname(fpath)console.log(fext) 3.5 综合案例 - 时钟案例 案例要实现的功能将素材目录下的 index.html 页面，拆分成三个文件，分别是： index.css index.js index.html并且将拆分出来的 3 个文件，存放到 clock 目录中。 案例的实现步骤① 创建两个正则表达式，分别用来匹配 style 和 script 标签② 使用 fs 模块，读取需要被处理的 HTML 文件③ 自定义 resolveCSS 方法，来写入 index.css 样式文件④ 自定义 resolveJS 方法，来写入 index.js 脚本文件⑤ 自定义 resolveHTML 方法，来写入 index.html 文件 步骤1 - 导入需要的模块并创建正则表达式12345678// 1.1 导入 fs 模块const fs = require('fs')// 1.2 导入 path 模块const path = require('path')// 1.3 定义正则表达式，分别匹配 &lt;style&gt;&lt;/style&gt; 和 &lt;script&gt;&lt;/script&gt; 标签const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;/ 步骤2 - 使用 fs 模块读取需要被处理的 html 文件12345678fs.readFile(path.join(__dirname, '../素材/index.html'), 'utf8', function(err, dataStr) { // 2.2 读取 HTML 文件失败 if (err) return console.log('读取HTML文件失败！' + err.message) // 2.3 读取文件成功后，调用对应的三个方法，分别拆解出 css, js, html 文件 resolveCSS(dataStr) resolveJS(dataStr) resolveHTML(dataStr)}) 步骤3 – 自定义 resolveCSS 方法123456789101112// 3.1 定义处理 css 样式的方法function resolveCSS(htmlStr) { // 3.2 使用正则提取需要的内容 const r1 = regStyle.exec(htmlStr) // 3.3 将提取出来的样式字符串，进行字符串的 replace 替换操作 const newCSS = r1[0].replace('&lt;style&gt;', '').replace('&lt;/style&gt;', '') // 3.4 调用 fs.writeFile() 方法，将提取的样式，写入到 clock 目录中 index.css 的文件里面 fs.writeFile(path.join(__dirname, './clock/index.css'), newCSS, function(err) { if (err) return console.log('写入 CSS 样式失败！' + err.message) console.log('写入样式文件成功！') })} 步骤4 – 自定义 resolveJS 方法123456789101112// 4.1 定义处理 js 脚本的方法function resolveJS(htmlStr) { // 4.2 通过正则，提取对应的 &lt;script&gt;&lt;/script&gt; 标签内容 const r2 = regScript.exec(htmlStr) // 4.3 将提取出来的内容，做进一步的处理 const newJS = r2[0].replace('&lt;script&gt;', '').replace('&lt;/script&gt;', '') // 4.4 将处理的结果，写入到 clock 目录中的 index.js 文件里面 fs.writeFile(path.join(__dirname, './clock/index.js'), newJS, function(err) { if (err) return console.log('写入 JavaScript 脚本失败！' + err.message) console.log('写入 JS 脚本成功！') })} 步骤5 – 自定义 resolveHTML 方法12345678910// 5.1 定义处理 HTML 结构的方法function resolveHTML(htmlStr) { // 5.2 将字符串调用 replace 方法，把内嵌的 style 和 script 标签，替换为外联的 link 和 script 标签 const newHTML = htmlStr.replace(regStyle, '&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; /&gt;').replace(regScript, '&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;') // 5.3 写入 index.html 这个文件 fs.writeFile(path.join(__dirname, './clock/index.html'), newHTML, function(err) { if (err) return console.log('写入 HTML 文件失败！' + err.message) console.log('写入 HTML 页面成功！') })} 4. 案例的两个注意点① fs.writeFile() 方法只能用来创建文件，不能用来创建路径② 重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容","link":"/2022/05/12/Node-js-5-12-2/"},{"title":"Node.js.5.12.3","text":"4. http 模块4.1 什么是 http 模块回顾：什么是客户端、什么是服务器？在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。如果要希望使用 http 模块创建 Web 服务器，则需要先导入它： 1const http -require( &quot; http ') 4.2 进一步理解 http 模块的作用服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的http 模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供 web 服务。 4.3 服务器相关的概念 IP 地址IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）注意：① 互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。② 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个IP 地址，就能把自己的电脑当做一台服务器进行访问了。 域名和域名服务器尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。 注意：① 单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。② 在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。3. 端口号计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。注意：① 每个端口号不能同时被多个 web 服务占用。② 在实际应用中，URL 中的 80 端口可以被省略。 4.4 创建最基本的 web 服务器 创建 web 服务器的基本步骤① 导入 http 模块② 创建 web 服务器实例③ 为服务器实例绑定 request 事件，监听客户端的请求④ 启动服务器 步骤1 - 导入 http 模块如果希望在自己的电脑上创建一个 web 服务器，从而对外提供 web 服务，则需要导入 http 模块：1const http = require('http') 步骤2 - 创建 web 服务器实例调用 http.createServer() 方法，即可快速创建一个 web 服务器实例：const server = http.createServer() 步骤3 - 为服务器实例绑定 request 事件为服务器实例绑定 request 事件，即可监听客户端发送过来的网络请求：1234// 3. 为服务器实例绑定 request 事件，监听客户端的请求server.on('request', function (req, res) { console.log('Someone visit our web server.')}) 步骤4 - 启动服务器调用服务器实例的 .listen() 方法，即可启动当前的 web 服务器实例：1234// 4. 启动服务器server.listen(8080, function () { console.log('server running at http://127.0.0.1:8080')}) req 请求对象只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式：12345678910111213141516const http = require('http')const server = http.createServer()// req 是请求对象，包含了与客户端相关的数据和属性server.on('request', (req, res) =&gt; { // req.url 是客户端请求的 URL 地址 const url = req.url // req.method 是客户端请求的 method 类型 const method = req.method const str = `Your request url is ${url}, and request method is ${method}` console.log(str) // 调用 res.end() 方法，向客户端响应一些内容 res.end(str)})server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1')}) res 响应对象在服务器的 request 事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式：123456789101112131415const http = require('http')const server = http.createServer()server.on('request', (req, res) =&gt; { // 定义一个字符串，包含中文的内容 const str = `您请求的 URL 地址是 ${req.url}，请求的 method 类型为 ${req.method}` // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题 res.setHeader('Content-Type', 'text/html; charset=utf-8') // res.end() 将内容响应给客户端 res.end(str)})server.listen(80, () =&gt; { console.log('server running at http://127.0.0.1')}) 4.5 根据不同的 url 响应不同的 html 内容 核心实现步骤① 获取请求的 url 地址② 设置默认的响应内容为 404 Not found③ 判断用户请求的是否为 / 或 /index.html 首页④ 判断用户请求的是否为 /about.html 关于页面⑤ 设置 Content-Type 响应头，防止中文乱码⑥ 使用 res.end() 把内容响应给客户端","link":"/2022/05/12/Node-js-5-12-3/"},{"title":"Node.js.5.12.1","text":"2.fs 文件系统模块2.1 什么是 fs 文件系统模块fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如： fs.readFile() 方法，用来读取指定文件中的内容 fs.writeFile() 方法，用来向指定的文件中写入内容如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：12const fs =require( 'fs ')--- 2.2 读取指定文件中的内容 fs.readFile() 的语法格式使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下：1fs.readFile(path[, options], callback) 参数解读： 参数1：必选参数，字符串，表示文件的路径。 参数2：可选参数，表示以什么编码格式来读取文件。 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。 fs.readFile() 的示例代码以 utf8 的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值：12345const fs = require('fs')fs.readFile('../code/files/1.txt', 'utf8', (err, data_str) =&gt; { console.log(err); console.log(data_str);}) 判断文件是否读取成功可以判断 err 对象是否为 null，从而知晓文件读取的结果：12345const fs = require( 'fs ')fs.readFile( ' .ifiles/1.txt&quot;,'utf8&quot;, function(err, result) { if (err) {return console.log('文件读取失败! ' + err.message)}console.log('文件读取成功,内容是:' t result)}) 2.3 向指定的文件中写入内容 fs.writeFile() 的语法格式使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：参数解读：1fs.writeFile(file, data[, options], callback) 参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。 参数2：必选参数，表示要写入的内容。 参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。 参数4：必选参数，文件写入完成后的回调函数。 fs.writeFile() 的示例代码向指定的文件路径中，写入文件内容：1234const fs = require('fs')fs.writeFile(&quot;../code/files/1.txt&quot;, 'hello Node.js', err =&gt; { console.log(err);}) 判断文件是否写入成功可以判断 err 对象是否为 null，从而知晓文件写入的结果：12345678const fs = require('fs')fs.readFile('./files/11.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)}) 2.5 练习 - 考试成绩整理使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。核心实现步骤① 导入需要的 fs 文件系统模块② 使用 fs.readFile() 方法，读取素材目录下的 成绩.txt 文件③ 判断文件是否读取失败④ 文件读取成功后，处理成绩数据⑤ 将处理完成的成绩数据，调用 fs.writeFile() 方法，写入到新文件 成绩-ok.txt 中 1234567891011121314151617181920212223242526272829// 1. 导入 fs 模块const fs = require('fs')// 2. 调用 fs.readFile() 读取文件的内容fs.readFile('../素材/成绩.txt', 'utf8', function(err, dataStr) { // 3. 判断是否读取成功 if (err) { return console.log('读取文件失败！' + err.message) } // console.log('读取文件成功！' + dataStr) // 4.1 先把成绩的数据，按照空格进行分割 const arrOld = dataStr.split(' ') // 4.2 循环分割后的数组，对每一项数据，进行字符串的替换操作 const arrNew = [] arrOld.forEach(item =&gt; { arrNew.push(item.replace('=', '：')) }) // 4.3 把新数组中的每一项，进行合并，得到一个新的字符串 const newStr = arrNew.join('\\r\\n') // 5. 调用 fs.writeFile() 方法，把处理完毕的成绩，写入到新文件中 fs.writeFile('./files/成绩-ok.txt', newStr, function(err) { if (err) { return console.log('写入文件失败！' + err.message) } console.log('成绩写入成功！') })}) 2.6 fs 模块 - 路径动态拼接的问题在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。 1234567891011121314151617181920212223242526272829const fs = require('fs')// 出现路径拼接错误的问题，是因为提供了 ./ 或 ../ 开头的相对路径// 如果要解决这个问题，可以直接提供一个完整的文件存放路径就行/* fs.readFile('./files/1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)}) */// 移植性非常差、不利于维护/* fs.readFile('C:\\\\Users\\\\escook\\\\Desktop\\\\Node.js基础\\\\day1\\\\code\\\\files\\\\1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)}) */// __dirname 表示当前文件所处的目录// console.log(__dirname)fs.readFile(__dirname + '/files/1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr)})","link":"/2022/05/12/Node-js-5-12-1/"}],"tags":[{"name":"CET4","slug":"CET4","link":"/tags/CET4/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"复习","slug":"复习","link":"/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"英语","slug":"英语","link":"/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"项目开发","slug":"项目开发","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"},{"name":"Vue.js","slug":"Vue-js","link":"/categories/Vue-js/"}]}